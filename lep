#!/usr/bin/env bash
# This script was generated by bashly 1.0.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
lep_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  else
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep COMMAND\n"
  printf "  lep [COMMAND] --help | -h\n"
  printf "  lep --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Upload latest episode and start automatic post processing workflow\n" "upload         "
  printf "  %s   Start new auphonic production\n" "auphonic       "
  printf "  %s   Create wordpress blogpost on http://laufendentdecken-podcast.at\n" "create-blogpost"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
lep_upload_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep upload - Upload latest episode and start automatic post processing workflow\n"
    echo

  else
    printf "lep upload - Upload latest episode and start automatic post processing workflow\n"
    echo

  fi

  printf "Alias: up\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep upload [OPTIONS]\n"
  printf "  lep upload --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--m4a, -m M4A (required)"
    printf "    Episode to upload as m4a\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep upload --m4a episode.m4a\n"
    echo

  fi
}

# :command.usage
lep_auphonic_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep auphonic - Start new auphonic production\n"
    echo

  else
    printf "lep auphonic - Start new auphonic production\n"
    echo

  fi

  printf "Alias: a\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep auphonic [OPTIONS]\n"
  printf "  lep auphonic --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--production_name, -n PRODUCTION_NAME (required)"
    printf "    Auphonic production name\n"
    echo

    # :flag.usage
    printf "  %s\n" "--preset, -p PRESET (required)"
    printf "    Auphonic preset\n"
    echo

    # :flag.usage
    printf "  %s\n" "--cover_url, -c COVER_URL (required)"
    printf "    URL of the cover image\n"
    echo

    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File name of the production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep auphonic --production_name episode1 --preset \"123823\" --cover_url\n  \"http://url\" --file episode1.m4a --slug episode1\n"
    echo

  fi
}

# :command.usage
lep_create_blogpost_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep create-blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  else
    printf "lep create-blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  fi

  printf "Alias: cb\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep create-blogpost [OPTIONS]\n"
  printf "  lep create-blogpost --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--number, -n NUMBER (required)"
    printf "    Episode Number\n"
    echo

    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep create-blogpost --number 1 --title \"Episode Title\" --publish_date\n  \"2049-12-31\" --slug \"slug\"\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/send_completions.sh
send_completions() {
  echo $'# lep completion                                           -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_lep_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_lep_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'upload\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help --skip-ftp -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'up\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help --skip-ftp -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help --version -h -v up upload")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _lep_completions lep'
  echo $''
  echo $'# ex: filetype=sh'
}

# :command.command_functions
# :command.function
lep_upload_command() {
  # src/upload_command.sh
  episode=${args[--m4a]}
  echo $episode

  op signin --account my.1password.com

  read -p "Episode Nummer: " postNumber
  read -p "Episode Titel: " postTitle
  read -p "Release (YYYY-MM-DD): " postDate

  title=$(echo "$episode" | cut -d'.' -f 1)
  chapters=$(<"$title".chapters.txt)
  cover="$title".png

  episode_patreon="$title"_patreon.m4a
  title_patreon="$title"_patreon

  coverYoutube="$title"_youtube.png
  baseUrl="https://rssfeed.laufendentdecken-podcast.at/data/"

  coverUrl="$baseUrl$cover"
  coverUrlYoutube="$baseUrl$coverYoutube"

  server_pwd=$(op item get "LEP_FTP" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')
  sudo=$(op item get "sudo" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')
  server_username=$(op item get "LEP_FTP" --format json | jq -r '. | .fields | .[] | select(.label=="username") | .value')

  echo "Upload episode to FTP Server"
  curl --user $server_username:$server_pwd --upload-file $episode ftp://rssfeed.laufendentdecken-podcast.at
  echo "Upload patreon episode to FTP Server"
  curl --user $server_username:$server_pwd --upload-file $episode_patreon ftp://rssfeed.laufendentdecken-podcast.at
  echo "Upload cover to FTP Server"
  curl --user $server_username:$server_pwd --upload-file $cover ftp://rssfeed.laufendentdecken-podcast.at
  echo "Upload youtube cover to FTP Server"
  curl --user $server_username:$server_pwd --upload-file $coverYoutube ftp://rssfeed.laufendentdecken-podcast.at

  echo "Backup to S3"

  aws s3 cp $episode s3://laufendentdecken-podcast/
  aws s3 cp s3://laufendentdecken-podcast/$episode s3://laufendentdecken-podcast-backup/

  aws s3 cp $episode_patreon s3://laufendentdecken-podcast/
  aws s3 cp s3://laufendentdecken-podcast/$episode_patreon s3://laufendentdecken-podcast-backup/

  lep auphonic  \
      --production_name $title \
      --preset "WbQunVJaZFitr3z74XTyxJ" \
      --cover_url $coverUrl \
      --file $episode \
      --slug $title

  lep auphonic  \
      --production_name "$title (Youtube)" \
      --preset "M9ageytQCjaFAYn7EjSYPZ" \
      --cover_url $coverUrlYoutube \
      --file $episode \
      --slug $title

  lep auphonic  \
      --production_name "$title (Patreon/Steady)" \
      --preset "WbQunVJaZFitr3z74XTyxJ" \
      --cover_url $coverUrl \
      --file $episode_patreon \
      --slug $title

  echo "Podcast successfully uploaded"

  echo "Download Patreon again to be able to upload it to the server"
  curl https://rssfeed.laufendentdecken-podcast.at/data/$title_patreon.mp3 --output ~/Downloads/$title_patreon.mp3

  echo "Create Episode on Website"

  lep create-blogpost \
      --number $postNumber \
      --title $postTitle \
      --publish_date $postDate \
      --slug $title

}

# :command.function
lep_auphonic_command() {
  # src/auphonic_command.sh
  title=${args[--slug]}
  episode=${args[--file]}
  coverUrl=${args[--cover_url]}
  auphonicTitle=${args[--production_name]}
  preset=${args[--preset]}

  chapters=$(<"$title".chapters.txt)

  auphonic_pwd=$(op item get "Auphonic" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')
  auphonic_username=$( op item get "Auphonic" --format json | jq -r '. | .fields | .[] | select(.purpose=="USERNAME") | .value')

  echo \n
  echo "Start $auphonicTitle Upload"

  json=$(curl -s -X POST https://auphonic.com/api/simple/productions.json \
       -u $auphonic_username:$auphonic_pwd \
       -F "preset=$preset" \
       -F "service=Tz96q8s6vs7JetJeqD6PCC" \
       -F "title=$auphonicTitle" \
       -F "track=$title" \
       -F "chapters=$chapters" \
       -F "input_file=$episode" \
       -F "image =$coverUrl"
       -F "action=start")

  content=$(echo $json | jq -r ' . | "\(.data.status_string):\(.data.uuid)"')
  IFS=':' read -ra response <<< "$content"

  status_string=${response[0]}
  uuid=${response[1]}

  echo "UUID: $uuid"
  echo -ne "Auphonic status: $status_string \r"

  while [[ $status_string != "Done"  ]]
  do
      json=$(curl -s -X GET https://auphonic.com/api/production/$uuid.json \
          -u $auphonic_username:$auphonic_pwd)

      status_string=$(echo $json | jq -r ' . | .data.status_string')

      echo -ne "Auphonic status: $status_string                         \r"
      sleep 2
  done

}

# :command.function
lep_create_blogpost_command() {
  # src/create_blogpost_command.sh
  postNumber=${args[--number]}
  postTitle=${args[--title]}
  postDate=${args[--publish_date]}
  slug=${args[--slug]}

  fullPostTitle="LEP#$postNumber - $postTitle"

  json=$(curl  -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes --header "Authorization: Basic ZmxvcmlhbjpkUUNZIG1BOGYgM0p1cyBEcjJ2IDlIZXAgb2p1Yg==")

  episodeId=$(echo $json | jq -r ' . | "\(.id)"')
  response=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId \
      --header "Authorization: Basic ZmxvcmlhbjpkUUNZIG1BOGYgM0p1cyBEcjJ2IDlIZXAgb2p1Yg==" \
      --header 'Content-Type: application/json; charset=utf-8' \
      -d "{ \"slug\": \"$slug\", \"title\": \"$fullPostTitle\", \"number\": \"$postNumber\" }")

  json=$(curl -s -X GET https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId --header "Authorization: Basic ZmxvcmlhbjpkUUNZIG1BOGYgM0p1cyBEcjJ2IDlIZXAgb2p1Yg==")
  postId=$(echo $json | jq -r ' . | "\(.post_id)"')

  response=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/wp/v2/episodes/$postId \
      --header "Authorization: Basic ZmxvcmlhbjpkUUNZIG1BOGYgM0p1cyBEcjJ2IDlIZXAgb2p1Yg==" \
      --header 'Content-Type: application/json; charset=utf-8' \
      --data-raw "{ \"title\":\"$fullPostTitle\", \"status\": \"future\", \"date\": \"$postDate 09:00:00\", \"slug\": \"$postNumber\" }")

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        lep_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    upload | up)
      action="upload"
      shift
      lep_upload_parse_requirements "$@"
      shift $#
      ;;

    auphonic | a)
      action="auphonic"
      shift
      lep_auphonic_parse_requirements "$@"
      shift $#
      ;;

    create-blogpost | cb)
      action="create-blogpost"
      shift
      lep_create_blogpost_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lep_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_upload_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_upload_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="upload"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --m4a | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--m4a']="$2"
          shift
          shift
        else
          printf "%s\n" "--m4a requires an argument: --m4a, -m M4A" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--m4a']+x} ]]; then
    printf "missing required flag: --m4a, -m M4A\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_auphonic_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_auphonic_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auphonic"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --production_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--production_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--production_name requires an argument: --production_name, -n PRODUCTION_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --preset | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--preset']="$2"
          shift
          shift
        else
          printf "%s\n" "--preset requires an argument: --preset, -p PRESET" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --cover_url | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--cover_url']="$2"
          shift
          shift
        else
          printf "%s\n" "--cover_url requires an argument: --cover_url, -c COVER_URL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--production_name']+x} ]]; then
    printf "missing required flag: --production_name, -n PRODUCTION_NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--preset']+x} ]]; then
    printf "missing required flag: --preset, -p PRESET\n" >&2
    exit 1
  fi
  if [[ -z ${args['--cover_url']+x} ]]; then
    printf "missing required flag: --cover_url, -c COVER_URL\n" >&2
    exit 1
  fi
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_create_blogpost_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_create_blogpost_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="create-blogpost"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --number | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--number']="$2"
          shift
          shift
        else
          printf "%s\n" "--number requires an argument: --number, -n NUMBER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--number']+x} ]]; then
    printf "missing required flag: --number, -n NUMBER\n" >&2
    exit 1
  fi
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "upload") lep_upload_command ;;
    "auphonic") lep_auphonic_command ;;
    "create-blogpost") lep_create_blogpost_command ;;
  esac
}

initialize
run "$@"
