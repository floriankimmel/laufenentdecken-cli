#!/usr/bin/env bash
# This script was generated by bashly 1.0.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
lep_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  else
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep COMMAND\n"
  printf "  lep [COMMAND] --help | -h\n"
  printf "  lep --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Configure youtube video\n" "youtube   "
  printf "  %s   Upload file to self hosted ftp server\n" "ftp       "
  printf "  %s   Upload latest episode and start automatic post processing workflow\n" "automation"
  printf "  %s   Start new auphonic production\n" "auphonic  "
  printf "  %s   Create wordpress blogpost on http://laufendentdecken-podcast.at\n" "blogpost  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
lep_youtube_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep youtube - Configure youtube video\n"
    echo

  else
    printf "lep youtube - Configure youtube video\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep youtube [OPTIONS]\n"
  printf "  lep youtube --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_ftp_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  else
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep ftp [OPTIONS]\n"
  printf "  lep ftp --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File to upload\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_automation_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  else
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep automation [OPTIONS]\n"
  printf "  lep automation --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--m4a, -m M4A"
    printf "    Episode as m4a\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-ftp"
    printf "    Skip upload to FTP server\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-aws"
    printf "    Skip upload to aws\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-auphonic"
    printf "    Skip upload to Auphonic\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-download"
    printf "    Skip download from patreon\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-blogpost"
    printf "    Skip create blogpost\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep upload --m4a episode.m4a\n"
    echo

  fi
}

# :command.usage
lep_auphonic_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep auphonic - Start new auphonic production\n"
    echo

  else
    printf "lep auphonic - Start new auphonic production\n"
    echo

  fi

  printf "Alias: a\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep auphonic [OPTIONS]\n"
  printf "  lep auphonic --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--production_name, -n PRODUCTION_NAME (required)"
    printf "    Auphonic production name\n"
    echo

    # :flag.usage
    printf "  %s\n" "--preset, -p PRESET (required)"
    printf "    Auphonic preset\n"
    echo

    # :flag.usage
    printf "  %s\n" "--cover_url, -c COVER_URL (required)"
    printf "    URL of the cover image\n"
    echo

    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File name of the production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--description, -d DESCRIPTION"
    printf "    Description of the episode\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-start"
    printf "    Dont automatically start the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep auphonic --production_name episode1 --preset \"123823\" --cover_url\n  \"http://url\" --file episode1.m4a --slug episode1\n"
    echo

  fi
}

# :command.usage
lep_blogpost_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  else
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  fi

  printf "Alias: cb\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep blogpost [OPTIONS]\n"
  printf "  lep blogpost --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--number, -n NUMBER (required)"
    printf "    Episode Number\n"
    echo

    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep create-blogpost --number 1 --title \"Episode Title\" --publish_date\n  \"2049-12-31\" --slug \"slug\"\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions
# :command.function
lep_youtube_command() {
  # src/youtube_command.sh
  #!/bin/bash

  API_KEY=$(op item get "YoutubeApiKey" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')

  # Set the title of the video you want to search for
  local string="LEP#125"

  local length="${#string}"
  local result=''

  for ((i = 0; i < length; i++)); do
      local char="${string:i:1}"
      case $char in
          [a-zA-Z0-9.~_-])
              result+="$char"
              ;;
          *)
              printf -v hex '%%%02X' "'$char"
              result+="$hex"
              ;;
      esac
  done

  # Send a request to the YouTube Data API to search for the video
  JSON=$(curl -s "https://www.googleapis.com/youtube/v3/search?key=$API_KEY&q=$result&part=id&part=snippet&maxResults=1&type=video")

  # Parse the JSON response to extract the video ID
  VIDEO_ID=$(echo "$JSON" | jq -r '.items[0].id.videoId')

  # Print the video ID
  echo "The video ID for \"$result\" is: $VIDEO_ID"

  # Set the necessary scopes for the API request
  SCOPES="https://www.googleapis.com/auth/youtube.force-ssl"

  # Set your API key file path and application name
  API_KEY_FILE="/Users/fkimmel/Dropbox/Tresor/key.json"
  APPLICATION_NAME="CLI"

  # Get the OAuth 2.0 access token
  ACCESS_TOKEN=$(google-oauthlib-tool --client-secrets $API_KEY_FILE \
                    --scope $SCOPES \
                    --save \
                    | grep access_token \
                    | cut -d' ' -f2)

  DESCRIPTION="LEP#125 - Wir zwei allein heut Nacht"
  PUBLISH_DATE="2021-11-12T09:00:00.000Z"

  echo $ACCESS_TOKEN

  # Construct the request body
  REQUEST_BODY=$(jq -n --arg desc "$DESCRIPTION" --arg date "$PUBLISH_DATE" '{snippet: {description: $desc, publishedAt: $date}}')

  # Make the API request to update the video
  curl --request PUT "https://www.googleapis.com/youtube/v3/videos?part=snippet&id=$VIDEO_ID" \
      --header "Authorization: Bearer $ACCESS_TOKEN" \
      --header "Content-Type: application/json" \
      --data "$REQUEST_BODY"

}

# :command.function
lep_ftp_command() {
  # src/ftp_command.sh
  file=${args[--file]}

  server_pwd=$(op item get "LEP_FTP" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')
  server_username=$(op item get "LEP_FTP" --format json | jq -r '. | .fields | .[] | select(.label=="username") | .value')

  curl --user $server_username:$server_pwd --upload-file $file ftp://rssfeed.laufendentdecken-podcast.at

}

# :command.function
lep_automation_command() {
  # src/automation_command.sh
  skipFtp=${args[--skip-ftp]}
  skipAws=${args[--skip-aws]}
  skipAuphonic=${args[--skip-auphonic]}
  skipDownload=${args[--skip-download]}
  skipBlogpost=${args[--skip-blogpost]}

  ag1=${args[--ag1]}

  episode=${args[--m4a]}
  if [[ -z "$episode" ]]; then
      shopt -s nullglob # um die Schleife zu vermeiden, wenn keine m4a-Dateien vorhanden sind
      for file in ./*.m4a; do
          episode=$(basename "$file")
          break
      done
  fi

  echo "Start automatic workflow for file $episode"

  title=$(echo "$episode" | cut -d'.' -f 1)
  dataFile="$title".txt

  if [[ -e $dataFile ]]; then
      IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$dataFile")"
  else
      while true; do
          read -p "Episode Nummer: " postNumber

          if [[ "$postNumber" =~ ^[0-9]*$ ]]; then
              break

          fi
      done
      read -p "Episode Titel: " postTitle

      while true; do
          read -p "Release (YYYY-MM-DD): " postDate

          if [[ "$postDate" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
              break

          fi
      done

      echo "$postNumber,$postTitle,$postDate" >> $dataFile
  fi

  echo "Automate episode 'LEP#$postNumber - $postTitle' scheduled for $postDate"

  chapters=$(<"$title".chapters.txt)
  cover="$title".png

  if [[ -n "$ag1" ]]; then
      episodeAdFree="$title"_addfree.m4a
      titleAdFree="$title"_addfree
  else
      episodeAdFree=$episode
      titleAdFree=$title
  fi

  coverYoutube="$title"_youtube.png
  baseUrl="https://rssfeed.laufendentdecken-podcast.at/data/"

  coverUrl="$baseUrl$cover"
  coverUrlYoutube="$baseUrl$coverYoutube"

  if [[ -z "$skipFtp" ]]; then
      echo
      echo "Upload episode to FTP Server"
      lep ftp --file $episode

      if [[ -n "$ag1" ]]; then
          echo "Upload addfree episode to FTP Server"
          lep ftp --file $episodeAdFree
      fi

      echo "Upload cover to FTP Server"
      lep ftp --file $cover
      echo "Upload youtube cover to FTP Server"
      lep ftp --file $coverYoutube

  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAws" ]]; then
      echo
      echo "Backup to S3"

      aws s3 cp $episode s3://laufendentdecken-podcast/
      aws s3 cp s3://laufendentdecken-podcast/$episode s3://laufendentdecken-podcast-backup/

      if [[ -n "$ag1" ]]; then
          aws s3 cp $episodeAdFree s3://laufendentdecken-podcast/
          aws s3 cp s3://laufendentdecken-podcast/$episodeAdFree s3://laufendentdecken-podcast-backup/
      fi
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAuphonic" ]]; then
      episodePreset="WbQunVJaZFitr3z74XTyxJ"
      youtubePreset="M9ageytQCjaFAYn7EjSYPZ"

      youtubeDescription=$(echo -e "Hört rein auf:\n🔗Https://laufendentdecken.at/$postNumber/\n\nUnd natürlich auf\n🎧Spotify, iTunes, Google Podcast, zencastr und in allen podcatchern über das RSS Feed.\n\n✅ Folge uns auf Instagram @laufendentdeckenpodcast , @floderandere und @redendentdecken\n\nUnd auf Facebook https://www.facebook.com/laufendentdeckenpodcast/\n\nWer uns unterstützen mag: https://www.patreon.com/laufendentdecken\noder Steady: https://steadyhq.com/de/laufendentdecken")

      lep auphonic  \
          --production_name $title \
          --preset $episodePreset\
          --cover_url $coverUrl \
          --file $episode \
          --slug $title

      lep auphonic  \
          --production_name "LEP#$postNumber - $postTitle" \
          --preset $youtubePreset \
          --cover_url $coverUrlYoutube \
          --file $episode \
          --slug $title \
          --description "$youtubeDescription"

      if [[ -n "$ag1" ]]; then
          lep auphonic  \
              --production_name "$title (addfree)" \
              --preset $episodePreset \
              --cover_url $coverUrl \
              --file $episodeAdFree \
              --slug $title
      fi

      echo "Podcast successfully uploaded"
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipDownload" ]]; then
      echo
      echo "Download adfree version again to be able to upload it to patroen/steady"
      curl https://rssfeed.laufendentdecken-podcast.at/data/$titleAdFree.mp3 --output ~/Downloads/$titleAdFree.mp3
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipBlogpost" ]]; then
      echo
      echo "Create Episode on Website"

      if [[ -z "$ag1" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date $postDate \
              --slug $title
      fi

      if [[ -n "$ag1" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date $postDate \
              --slug $title \
              --ag1
      fi

  fi

}

# :command.function
lep_auphonic_command() {
  # src/auphonic_command.sh
  title=${args[--slug]}
  episode=${args[--file]}
  coverUrl=${args[--cover_url]}
  auphonicTitle=${args[--production_name]}
  preset=${args[--preset]}
  noStart=${args[--no-start]}
  description=${args[--description]}

  chapters=$(<"$title".chapters.txt)

  auphonic_pwd=$(op item get "Auphonic" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')
  auphonic_username=$( op item get "Auphonic" --format json | jq -r '. | .fields | .[] | select(.purpose=="USERNAME") | .value')

  action="start"

  # If no start is set, we just want to save the production
  if [[ -n "$noStart" ]]; then
      action="save"
  fi

  echo
  echo "Create $auphonicTitle Production"
  json=$(curl -s -X POST https://auphonic.com/api/simple/productions.json \
       -u $auphonic_username:$auphonic_pwd \
       -F "preset=$preset" \
       -F "service=Tz96q8s6vs7JetJeqD6PCC" \
       -F "title=$auphonicTitle" \
       -F "track=$title" \
       -F "chapters=$chapters" \
       -F "input_file=$episode" \
       -F "image=$coverUrl" \
       -F "summary=$description" \
       -F "action=$action")

  # Only query the status if we started the production
  if [[ -z "$noStart" ]]; then
      echo "Production started"
      content=$(echo $json | jq -r ' . | "\(.data.status_string):\(.data.uuid)"')
      IFS=':' read -ra response <<< "$content"

      status_string=${response[0]}
      uuid=${response[1]}

      echo "UUID: $uuid"
      echo -ne "Auphonic status: $status_string \r"

      while [[ $status_string != "Done"  ]]
      do
          json=$(curl -s -X GET https://auphonic.com/api/production/$uuid.json \
              -u $auphonic_username:$auphonic_pwd)

          status_string=$(echo $json | jq -r ' . | .data.status_string')

          echo -ne "Auphonic status: $status_string                         \r"
          sleep 2
      done
  else
      echo "Production $auphonicTitle saved"
  fi

}

# :command.function
lep_blogpost_command() {
  # src/blogpost_command.sh
  postNumber=${args[--number]}
  postTitle=${args[--title]}
  postDate=${args[--publish_date]}
  slug=${args[--slug]}

  ag1=${args[--ag1]}

  fullPostTitle="LEP#$postNumber - $postTitle"

  if [[ $postTitle == "Ein Gespräch mit "* ]]; then
      guest=${postTitle#"Ein Gespräch mit "}
      guest="Mehr Informationen zu $guest: Instagram | Facebook <br><br>"
  else
      guest=""
  fi

  content="<b>Werbefrei</b><br><br>Zusätzlich habt ihr ab sofort die Möglichkeit euch das exklusive <a href='https://www.patreon.com/laufendentdecken'>Patreonfeed</a> zu sichern – werbefrei und liebevoll exportiert.<br><br>Am besten direkt mitmachen und unterstützen: <a href='https://www.patreon.com/laufendentdecken'>Patreon</a><br><br><b>Links zum weiterlesen</b><br><br>$guest Wenn ihr den Podcast direkt ohne Installation hören möchtet, könnt ihr das hier tun: Laufend Entdecken auf Podbay<br><br>Florian: <a href='http://twitter.com/laufenentdecken'>Twitter</a>, <a href='https://www.strava.com/athletes/1651823'>Strava</a><br>Peter: <a href='https://twitter.com/redendentdecken'>Twitter</a>, <a href='https://www.instagram.com/redendentdecken'>Instagram</a>, <a href='https://www.strava.com/athletes/24464941'>Strava</a><br><br><a href='http://facebook.com/laufendentdeckenblog/'>Facebook</a>, <a href='https://instagram.com/laufendentdeckenpodcast/'>Instagram</a>, <a href='https://www.strava.com/clubs/473847'>Strava Club</a>"

  if [[ -n "$ag1" ]]; then
      content="<b>Werbung</b><br><br>Informiere dich jetzt auf <a href='http://athleticgreens.com/laufendentdecken'>athleticgreens.com/laufendentdecken</a> , teste AG1 völlig risikofrei mit 90 Tagen Geld-zurück-Garantie und sichere dir bei deiner AG1 Erstbestellung einen kostenlosen Jahresvorrat an Vitamin D3+K2 zur Unterstützung des Immunsystems & 5 praktische Travel Packs! Gesundheitsbezogene Angaben zu AG1 und unser Angebot findest du auf: <a href='http://athleticgreens.com/laufendentdecken'>athleticgreens.com/laufendentdecken</a><br><br>Auf die Bedeutung einer abwechslungsreichen und ausgewogenen Ernährung und einer gesunden Lebensweise wird hingewiesen. Außer Reichweite von Kindern aufbewahren. Nicht geeignet für Kinder und Jugendliche unter 18 Jahren, schwangere oder stillende Frauen. Die angegebene empfohlene tägliche Verzehrmenge darf nicht überschritten werden.<br><br>$content"
  fi

  apiKey=$(op item get "PodloveApiKey" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')

  json=$(curl  -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes --header "Authorization: Basic $apiKey")

  episodeId=$(echo $json | jq -r ' . | "\(.id)"')
  response=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      -d "{ \"slug\": \"$slug\", \"title\": \"$fullPostTitle\", \"number\": \"$postNumber\" }")

  json=$(curl -s -X GET https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId --header "Authorization: Basic $apiKey")
  postId=$(echo $json | jq -r ' . | "\(.post_id)"')

  response=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/wp/v2/episodes/$postId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      --data-raw "{ \"title\":\"$fullPostTitle\", \"status\": \"future\", \"date\": \"$postDate 09:00:00\", \"slug\": \"$postNumber\", \"content\": \"<!-- wp:paragraph --> <!-- /wp:paragraph --> <!-- wp:paragraph -->$content<!-- /wp:paragraph -->\" }")

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        lep_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "install by running: 'brew install awscli'" >&2
    exit 1
  fi

  if command -v op >/dev/null 2>&1; then
    deps['op']="$(command -v op | head -n1)"
  else
    printf "missing dependency: op\n" >&2
    printf "%s\n" "install by running: 'brew install 1password-cli'" >&2
    exit 1
  fi

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    printf "%s\n" "install by running: 'brew install jq'" >&2
    exit 1
  fi

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "Please install curl" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    youtube)
      action="youtube"
      shift
      lep_youtube_parse_requirements "$@"
      shift $#
      ;;

    ftp)
      action="ftp"
      shift
      lep_ftp_parse_requirements "$@"
      shift $#
      ;;

    automation)
      action="automation"
      shift
      lep_automation_parse_requirements "$@"
      shift $#
      ;;

    auphonic | a)
      action="auphonic"
      shift
      lep_auphonic_parse_requirements "$@"
      shift $#
      ;;

    blogpost | cb)
      action="blogpost"
      shift
      lep_blogpost_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lep_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_youtube_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_youtube_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="youtube"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_ftp_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_ftp_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ftp"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_automation_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_automation_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="automation"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --m4a | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_file_exists "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--m4a, -m M4A" "$(validate_file_exists "$2")" >&2
            exit 1
          fi

          args['--m4a']="$2"
          shift
          shift
        else
          printf "%s\n" "--m4a requires an argument: --m4a, -m M4A" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --skip-ftp)

        # :flag.case_no_arg
        args['--skip-ftp']=1
        shift
        ;;

      # :flag.case
      --skip-aws)

        # :flag.case_no_arg
        args['--skip-aws']=1
        shift
        ;;

      # :flag.case
      --skip-auphonic)

        # :flag.case_no_arg
        args['--skip-auphonic']=1
        shift
        ;;

      # :flag.case
      --skip-download)

        # :flag.case_no_arg
        args['--skip-download']=1
        shift
        ;;

      # :flag.case
      --skip-blogpost)

        # :flag.case_no_arg
        args['--skip-blogpost']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_auphonic_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_auphonic_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auphonic"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --production_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--production_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--production_name requires an argument: --production_name, -n PRODUCTION_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --preset | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--preset']="$2"
          shift
          shift
        else
          printf "%s\n" "--preset requires an argument: --preset, -p PRESET" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --cover_url | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--cover_url']="$2"
          shift
          shift
        else
          printf "%s\n" "--cover_url requires an argument: --cover_url, -c COVER_URL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --description | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description, -d DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-start)

        # :flag.case_no_arg
        args['--no-start']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--production_name']+x} ]]; then
    printf "missing required flag: --production_name, -n PRODUCTION_NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--preset']+x} ]]; then
    printf "missing required flag: --preset, -p PRESET\n" >&2
    exit 1
  fi
  if [[ -z ${args['--cover_url']+x} ]]; then
    printf "missing required flag: --cover_url, -c COVER_URL\n" >&2
    exit 1
  fi
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_blogpost_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_blogpost_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="blogpost"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --number | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--number']="$2"
          shift
          shift
        else
          printf "%s\n" "--number requires an argument: --number, -n NUMBER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--number']+x} ]]; then
    printf "missing required flag: --number, -n NUMBER\n" >&2
    exit 1
  fi
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  op signin --account my.1password.com

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "youtube") lep_youtube_command ;;
    "ftp") lep_ftp_command ;;
    "automation") lep_automation_command ;;
    "auphonic") lep_auphonic_command ;;
    "blogpost") lep_blogpost_command ;;
  esac
}

initialize
run "$@"
